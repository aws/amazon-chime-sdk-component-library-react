#!/usr/bin/env node

const { argv, env, kill, exit } = require('process');
const { spawnSync, spawn } = require('child_process');
const args = require('minimist')(argv.slice(2));
const path = require('path');

const pathToIntegrationFolder = path.resolve(__dirname, '..');
const pathToTestDemoFolder = path.resolve(__dirname, '../app/test-demo');

const green = '\x1b[32m%s\x1b[0m';
const red = '\x1b[31m%s\x1b[0m';

function runAsync(command, args, options) {
  options = {
    ...options,
    shell: true
  };
  const child = spawn(command, args, options);

  child.stdout.setEncoding('utf8');
  child.stdout.on('data', (data) => {
    console.log(data);
  });

  child.stderr.setEncoding('utf8');
  child.stderr.on('data', (error) => {
    console.log(red, error);
  });

  child.on('close', (code) => {
    console.log(red, `Command ${command} exited with ${code}`);
  });

  return child.pid;
}

function runSync(command, args, options, printOutput = true) {
  options = {
    ...options,
    shell: true
  };
  const child = spawnSync(command, args, options);

  const output = child.stdout.toString();
  if (printOutput) {
    console.log(output);
  }

  if (child.error) {
    console.log(red, `Command ${command} failed with ${child.error.code}`);
  }

  if (child.status !== 0) {
    console.log(red, `Command ${command} failed with exit code ${child.status} and signal ${child.signal}`);
    console.log(red, child.stderr.toString());
  }

  return output;
}

const checkIfPortIsInUse = async port =>
  new Promise(resolve => {
    const server = require('http')
      .createServer()
      .listen(port, 'localhost', () => {
        server.close();
        resolve(false);
      })
      .on('error', () => {
        resolve(true);
      });
  });

function startTestDemo() {
  console.log(green, 'Installing dependencies in test demo');
  runSync('npm', ['install'], { cwd: pathToTestDemoFolder });

  console.log(green, ' Starting the test demo');
  runAsync('npm', ['run', 'start'], { cwd: pathToTestDemoFolder });
}

const waitUntilTestDemoStarts = async () => {
  console.log(green, ' Waiting for test demo to start');
  count = 0;
  threshold = 60;

  while (count < 60) {
    const isInUse = await checkIfPortIsInUse(8080);
    if (isInUse === true) {
      console.log(green, ' Test demo has started successfully');
      return;
    }
    count += 1;
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }

  console.log(red, ' Test demo did not start successfully');
  terminateTestDemo(pid);
  exit(1);
};

const setupTestEnvironment = () => {
  if (args['host']) env.HOST = args['host'];
  if (args['browser-version']) env.BROWSER_VERSION = args['browser-version'];
  if (args['platform-name']) env.PLATFORM_NAME = args['platform-name'];
  console.log(green, ' Set up the test environment');
};

const startTesting = () => {
  console.log(green, ' Running test');
  let targetTest;
  switch (args['host']) {
    case 'roster':
      targetTest = 'test/roster_test.js';
      break;

    default:
      targetTest = 'test/*';
      break;
  }
  const testResult = runSync('mocha', [targetTest], { cwd: pathToIntegrationFolder });
  return testResult;
};

const terminateTestDemo = () => {
  const demoPid = runSync('lsof', ['-i', ':9000', '-t'], null, printOutput = false);
  if (demoPid) kill(demoPid, 'SIGKILL');

  const serverPid = runSync('lsof', ['-i', ':8080', '-t'], null, printOutput = false);
  if (serverPid) kill(serverPid, 'SIGKILL');
  console.log(green, 'Terminated the test demo');
};

const checkTestResult = (result) => {
  if (result.includes('failing')) {
    console.log(red, 'Did not pass all tests, failed');
    exit(1);
  } else {
    console.log(green, 'Passed all tests, succeeded');
    exit(0);
  }
};

(async () => {
  startTestDemo();
  await waitUntilTestDemoStarts();
  setupTestEnvironment();
  const testResult = startTesting();
  terminateTestDemo();
  checkTestResult(testResult);
})();
